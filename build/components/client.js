"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = __importStar(require("path"));
var fs_extra_1 = require("fs-extra");
var fs_extra_2 = require("fs-extra");
var fs = __importStar(require("fs"));
var util_1 = require("util");
var writeFile = util_1.promisify(fs.writeFile);
var toml_1 = __importDefault(require("@iarna/toml"));
var lodash_1 = require("lodash");
var tsTemplate = lodash_1.template("\n// Code generated by @open-rpc/generator DO NOT EDIT.\nimport { RequestManager, PostMessageWindowTransport, PostMessageIframeTransport, WebSocketTransport, HTTPTransport, Client, JSONRPCError } from \"@open-rpc/client-js\";\nimport _ from \"lodash\";\nimport { OpenrpcDocument as OpenRPC, MethodObject, ContentDescriptorObject } from \"@open-rpc/meta-schema\";\nimport { MethodCallValidator, MethodNotFoundError } from \"@open-rpc/schema-utils-js\";\n\n<%= methodTypings.toString(\"typescript\") %>\n\nexport interface Options {\n  transport: {\n    type: \"websocket\" | \"http\" | \"https\" | \"postmessagewindow\" | \"postmessageiframe\";\n    host: string;\n    port: number;\n    path?: string;\n    protocol?: string;\n  },\n}\n\nexport class <%= className %> {\n  public rpc: Client;\n  public static openrpcDocument: OpenRPC = <%= JSON.stringify(openrpcDocument) %> ;\n  public transport: HTTPTransport | WebSocketTransport | PostMessageWindowTransport | PostMessageIframeTransport;\n  private validator: MethodCallValidator;\n  private timeout: number | undefined;\n\n  constructor(options: Options) {\n\n    if (options.transport === undefined || options.transport.type === undefined) {\n      throw new Error(\"Invalid constructor params\");\n    }\n    const {type, host, port, protocol} = options.transport;\n    let path = options.transport.path || \"\";\n    if(path && path[0] !== \"/\") {\n        path = \"/\" + path;\n    }\n    switch (type) {\n      case 'http':\n      case 'https':\n        this.transport = new HTTPTransport((protocol || type) + \"://\" + host + \":\" + port + path);\n        break;\n      case 'websocket':\n        this.transport = new WebSocketTransport((protocol || \"ws://\") + host + \":\" + port + path);\n        break;\n      case 'postmessageiframe':\n        this.transport = new PostMessageIframeTransport(protocol + \"://\" + host + \":\" + port + path);\n        break;\n      case 'postmessagewindow':\n        this.transport = new PostMessageWindowTransport(protocol + \"://\" + host + \":\" + port + path);\n        break;\n      default:\n        throw new Error(\"unsupported transport\");\n        break;\n    }\n    this.rpc = new Client(new RequestManager([this.transport]));\n    this.validator = new MethodCallValidator(<%= className %>.openrpcDocument);\n  }\n  /**\n   * Adds a JSONRPC notification handler to handle receiving notifications.\n   * @example\n   * myClient.onNotification((data)=>console.log(data));\n   */\n  public onNotification(callback: (data: any) => void) {\n    this.rpc.onNotification(callback);\n  }\n\n  /**\n   * Adds an optional JSONRPCError handler to handle receiving errors that cannot be resolved to a specific request\n   * @example\n   * myClient.onError((err: JSONRPCError)=>console.log(err.message));\n   */\n  public onError(callback: (data: JSONRPCError) => void) {\n     this.rpc.onError(callback);\n  }\n\n  /**\n   * Sets a default timeout in ms for all requests excluding notifications.\n   * @example\n   * // 20s timeout\n   * myClient.setDefaultTimeout(20000);\n   * // Removes timeout from request\n   * myClient.setDefaultTimeout(undefined);\n   */\n   public setDefaultTimeout(ms?: number) {\n    this.timeout = ms;\n  }\n\n  /**\n   * Initiates [[<%= className %>.startBatch]] in order to build a batch call.\n   *\n   * Subsequent calls to [[<%= className %>.request]] will be added to the batch.\n   * Once [[<%= className %>.stopBatch]] is called, the promises for the [[<%= className %>.request]]\n   * will then be resolved.  If there is already a batch in progress this method is a noop.\n   *\n   * @example\n   * myClient.startBatch();\n   * myClient.foo().then(() => console.log(\"foobar\"))\n   * myClient.bar().then(() => console.log(\"foobarbaz\"))\n   * myClient.stopBatch();\n   */\n  public startBatch(): void {\n    return this.rpc.startBatch();\n  }\n\n  /**\n   * Initiates [[Client.stopBatch]] in order to finalize and send the batch to the underlying transport.\n   *\n   * stopBatch will send the [[<%= className %>]] calls made since the last [[<%= className %>.startBatch]] call. For\n   * that reason, [[<%= className %>.startBatch]] MUST be called before [[<%= className %>.stopBatch]].\n   *\n   * @example\n   * myClient.startBatch();\n   * myClient.foo().then(() => console.log(\"foobar\"))\n   * myClient.bar().then(() => console.log(\"foobarbaz\"))\n   * myClient.stopBatch();\n   */\n  public stopBatch(): void {\n    return this.rpc.stopBatch();\n  }\n\n  private request(methodName: string, params: any[]): Promise<any> {\n    const methodObject = _.find(<%= className %>.openrpcDocument.methods, ({name}:MethodObject) => name === methodName) as MethodObject;\n    const notification = methodObject.result ? false : true;\n    const openRpcMethodValidationErrors = this.validator.validate(methodName, params);\n    if ( openRpcMethodValidationErrors instanceof MethodNotFoundError || openRpcMethodValidationErrors.length > 0) {\n      return Promise.reject(openRpcMethodValidationErrors);\n    }\n\n    let rpcParams;\n    if (methodObject.paramStructure && methodObject.paramStructure === \"by-name\") {\n      rpcParams = _.zipObject(params, _.map(methodObject.params, \"name\"));\n    } else {\n      rpcParams = params;\n    }\n    if (notification) {\n      return this.rpc.notify({method: methodName, params: rpcParams});\n    }\n    return this.rpc.request({method: methodName, params: rpcParams}, this.timeout);\n  }\n\n  <% openrpcDocument.methods.filter((m)=>!m.namespace).forEach((method) => { %>\n  /**\n   * <%= method.summary %>\n   */\n  // tslint:disable-next-line:max-line-length\n  public <%= method.name %>: <%= methodTypings.getTypingNames(\"typescript\", method).method %> = (...params) => {\n    return this.request(\"<%= method.name %>\", params);\n  }\n  <% }); %>\n\n  <% openrpcDocument.namespaces.forEach((namespace) => { %>\n  public <%= namespace.name %> = new class{\n    constructor(public superThis: <%= className %>) {\n    }\n    <% namespace.methods.forEach((method) => { %>\n    /**\n     * <%= method.summary %>\n     */\n    // tslint:disable-next-line:max-line-length\n    public <%= method.validName %>: <%= methodTypings.getTypingNames(\"typescript\", method).method %> = (...params) => {\n      return this.superThis.request(\"<%= method.name %>\", params);\n    }\n    <% }); %>\n  }(this);\n  <% }); %>\n\n}\nexport default <%= className %>;\n");
var rsTemplate = lodash_1.template("\n#[macro_use]\nextern crate jsonrpc_client_core;\n\n<%= methodTypings.toString(\"rust\", { includeSchemaTypings: true, includeMethodAliasTypings: false }) %>\n\njsonrpc_client!(pub struct <%= className %> {\n<%= methodTypings.toString(\"rust\", { includeSchemaTypings: false, includeMethodAliasTypings: true }) %>\n});\n");
var hooks = {
    afterCopyStatic: [
        function (dest, frm, component) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(component.language === "typescript")) return [3 /*break*/, 2];
                        return [4 /*yield*/, fs_extra_1.move(path.join(dest, "_package.json"), path.join(dest, "package.json"), { overwrite: true })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/];
                }
            });
        }); },
    ],
    beforeCompileTemplate: [
        function (dest, frm, component, openrpcDocument, typings) { return __awaiter(void 0, void 0, void 0, function () {
            var namespaceCollection, _i, _a, method, _b, namespace, methodName, key;
            return __generator(this, function (_c) {
                if (component.language === "typescript") {
                    namespaceCollection = {};
                    for (_i = 0, _a = openrpcDocument.methods; _i < _a.length; _i++) {
                        method = _a[_i];
                        if (method.name.includes(".")) {
                            _b = method.name.split(/\.(.+)/), namespace = _b[0], methodName = _b[1];
                            method.namespace = namespace;
                            method.validName = methodName;
                            if (!namespaceCollection[namespace]) {
                                namespaceCollection[namespace] = [];
                            }
                            namespaceCollection[namespace].push(method);
                        }
                    }
                    openrpcDocument.namespaces = [];
                    for (key in namespaceCollection) {
                        if (namespaceCollection.hasOwnProperty(key)) {
                            openrpcDocument.namespaces.push({
                                name: key,
                                methods: namespaceCollection[key]
                            });
                        }
                    }
                }
                return [2 /*return*/];
            });
        }); }
    ],
    afterCompileTemplate: [
        function (dest, frm, component, openrpcDocument) { return __awaiter(void 0, void 0, void 0, function () {
            var packagePath, fileContents, pkg, updatedPkg, cargoTOMLPath, fileContents, cargoTOML, updatedCargo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(component.language === "typescript")) return [3 /*break*/, 3];
                        packagePath = path.join(dest, "package.json");
                        return [4 /*yield*/, fs_extra_2.readFile(packagePath)];
                    case 1:
                        fileContents = _a.sent();
                        pkg = JSON.parse(fileContents.toString());
                        updatedPkg = JSON.stringify(__assign(__assign({}, pkg), { name: component.name, version: openrpcDocument.info.version, repository: {
                                type: 'git',
                                url: component.repository
                            } }));
                        return [4 /*yield*/, writeFile(packagePath, updatedPkg)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        if (!(component.language === "rust")) return [3 /*break*/, 6];
                        cargoTOMLPath = path.join(dest, "Cargo.toml");
                        return [4 /*yield*/, fs_extra_2.readFile(cargoTOMLPath)];
                    case 4:
                        fileContents = _a.sent();
                        cargoTOML = toml_1.default.parse(fileContents.toString());
                        updatedCargo = toml_1.default.stringify(__assign(__assign({}, cargoTOML), { package: __assign(__assign({}, cargoTOML.package), { name: component.name, version: openrpcDocument.info.version }) }));
                        return [4 /*yield*/, writeFile(cargoTOMLPath, updatedCargo)];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6: return [2 /*return*/];
                }
            });
        }); },
    ],
    templateFiles: {
        typescript: [
            {
                path: "src/index.ts",
                template: tsTemplate,
            },
        ],
        rust: [
            {
                path: "src/index.rs",
                template: rsTemplate,
            },
        ],
    },
};
exports.default = hooks;
//# sourceMappingURL=client.js.map